#include "uart1.h" 
#include "delay.h" 
#include "timer.h" 
/*--------------------------------------------------------------*/
/* --- -----------------实验内容 -------------------------------*/
/* --- 1-了解STC-ISP工具生产延时函数方法 -----------------------*/
/* --- 2-掌握子函数的创建与调用---------------------------------*/
/* --- 实验平台：未来电子STC32核心板----------------------------*/
/* --- 视频学习：https://space.bilibili.com/494969171 ----------*/
/* --- QQ交流群：702805632 -------------------------------------*/
/* --- 参考资料：STC32实验室参考例程 ---------------------------*/
/*--------------------------------------------------------------*/

bit B_TX1_Busy; //发送忙标志
//==========================================================================

#define Baudrate1   (65536 - 24000000UL / 115200 / 4)
/***************************************************************************
 * 描  述 : 串口1初始化函数
 * 入  参 : 无
 * 返回值 : 无
备注：波特率9600bps   晶振24MHz
 **************************************************************************/
void Uart1_Init(void)
{	 
  P3M1 &= 0xFC;	P3M0 &= 0xFC;	                  //设置P3.0 ,P3.1为准双向口   
	TR1 = 0;
	S1BRT = 0;		//S1 BRT Use Timer1;
	T1_CT = 0;		//Timer1 set As Timer
	T1x12 = 1;		//Timer1 set as 1T mode
	TMOD &= ~0x30;//Timer1_16bitAutoReload;
	TH1 = (u8)(Baudrate1 / 256);
	TL1 = (u8)(Baudrate1 % 256);
	ET1 = 0;    //禁止定时器中断
	TR1 = 1;
	
	SCON = (SCON & 0x3f) | 0x40;    //UART1模式, 0x00: 同步移位输出, 0x40: 8位数据,可变波特率, 0x80: 9位数据,固定波特率, 0xc0: 9位数据,可变波特率
	ES  = 1;    //允许串口中断
	REN = 1;    //允许接收
	P_SW1 &= 0x3f;
	B_TX1_Busy = 0;
	
}

/***************************************************************************
 * 描  述 : 串口1发送数据函数
 * 入  参 : uint8 数据
 * 返回值 : 无
 **************************************************************************/
void SendDataByUart1(unsigned char dat)
{
    SBUF = dat;                 //写数据到UART数据寄存器
    B_TX1_Busy = 1;
    while(B_TX1_Busy);                   //清除TI位（该位必须软件清零）
} 
/***************************************************************************
 * 描  述 : 串口1中断服务函数
 * 入  参 : 无
 * 返回值 : 无
 **************************************************************************/
void Uart1() interrupt 4 using 1
{
	  ES = 0;  	                  // 串口1中断关闭
	  if (RI)                     //串行接收到停止位的中间时刻时，该位置1
   {
      RI = 0;                 //清除RI位 （该位必须软件清零）SBUF; 
      
   }
   if (TI)                    //在停止位开始发送时，该位置1
   {
      TI = 0;                 //清除TI位（该位必须软件清零） 
		  B_TX1_Busy = 0;
   }
	 ES =  1;                   // 串口1中断打开
}
//========================================================================
// 函数: void PrintString1(u8 *puts)
// 描述: 串口1发送字符串函数。
// 参数: puts:  字符串指针.
// 返回: none.
// 版本: VER1.0
// 日期: 2022-09-24
// 备注: 
//========================================================================
//void PrintString1(unsigned char *puts)
//{
//    for (; *puts != 0;  puts++)     //遇到停止符0结束
//    {
//        SBUF = *puts;
//        B_TX1_Busy = 1;
//        while(B_TX1_Busy);
//    }
//}
//========================================================================
// 函数: void program_automatic_update(void)
// 描述: 程序自动下载。
// 参数: 程序自动下载。.
// 返回: none.
// 版本: VER1.0
// 日期: 2022-09-24
// 备注: 
//======================================================================== 

//void program_automatic_update(void)
//{
//    static unsigned char recv_cnt = 0;
//    if (SBUF == 0xAF)
//    {
//        if (++recv_cnt >= 5)
//        {
//            recv_cnt = 0;
//            IAP_CONTR = 0x60;   //触发软件复位，从ISP开始执行
//        }
//    }
//    else
//    {
//        recv_cnt = 0;
//    }
//}













